Developer Documentation
==================

UML Diagram
-----------
.. image:: ../images/uml.png


Integrators and Moves
~~~~~~~~~~~~~~~~~~~~~
Integrators are the lowest level openmm objects this package interacts with, where each intergrator is tied to an `openmm.Context` that it advances. Each integrator is generated by using the embedded function  `_get_integrator()` function within each move class. The integrators will control whether we are carrying out the Non-equilibirum Candidate Monte Carlo (NCMC) or Molecular Dynamics (MD) simulation.

Every move class has 3 hidden functions: `_get_integrator()` for generating the integrator of each move class, `_before_integration()` for performing any necessary setup before integration, and `_after_integration()` for performing any cleanup or data collection after integration. Every move class also contains the `apply()` function which carries out stepping with the integrator.

In this package, we provide the move class `blues.ncmc.ReportLangevinDynamicsMove` to execute the MD simulation. As the name suggests, this will carry forward the MD simulation using Langevin dynamics, by generating an `openmm.LangevinIntegrator`. This class is essentially the same as the `openmmtools.LangevinDynamicsMove` but with modifications to the `apply()` function which allows storing simulation data for the MD simulation.

For running the NCMC simulation, we provide a custom integrator
`blues.integrator.AlchemicalExternalLangevinIntegrator`. This integrator is generated in every move which inherits from the base class `blues.ncmc.NCMCMove`. Every class which inherits from the base move class must override the `_propose_positions()` function. If necessary, one can override the `_before_integration()` and `_after_integration()` functions for any necessary setup and cleanup before a call is made to the `apply()` function to step forward with integrating the `openmm.Context`.

In order to implement custom NCMC moves, inherit from the base class and override the `_propose_positions()` function. This function takes in the positions array of the atoms to be modified and returns the proposed positions. In pseudo-code, it would look something like:

.. code-block:: python
   from blues.ncmc import NCMCMove
   class CustomNCMCMove(NCMCMove):
       def _propose_positions(positions):
           """Add 1 nanometer displacement vector."""
           positions_unit = positions.unit
           unitless_displacement = 1.0 / positions_unit
           displacement_vector = unit.Quantity(np.random.randn(3) * unitless_displacement_sigma, positions_unit)
           proposed_positions = positions + displacement_vector
           return proposed_positions

In this package, we provide the `blues.ncmc.RandomLigandRotationMove` in order to propose a random ligand rotation about the center of mass. This class overrides the `_before_integration()` function for obtaining the masses of the ligand and overrides the `_propose_positions()` function for generating the rotated coordinates. Applying the rotated coordinates to the context is handled when the `apply()` function is called in this move class. Code snippet of the class is shown below:

.. code-block:: python
   from blues.ncmc import RandomLigandRotationMove
   class RandomLigandRotationMove(NCMCMove):
      def _before_integration(self, context, thermodynamic_state):
         """Obtain the masses of the ligand before integration."""
         super(RandomLigandRotationMove, self)._before_integration(context, thermodynamic_state)
         masses, totalmass = utils.getMasses(self.atom_subset, thermodynamic_state.topology)
         self.masses = masses
      def _propose_positions(self, positions):
          # Calculate the center of mass
          center_of_mass = utils.getCenterOfMass(positions, self.masses)
          reduced_pos = positions - center_of_mass
          # Define random rotational move on the ligand
          rand_quat = mdtraj.utils.uniform_quaternion(size=None)
          rand_rotation_matrix = mdtraj.utils.rotation_matrix_from_quaternion(rand_quat)
          # multiply lig coordinates by rot matrix and add back COM translation from origin
          proposed_positions = numpy.dot(reduced_pos, rand_rotation_matrix) * positions.unit + center_of_mass

          return proposed_positions

Since BLUES (v0.2.5) the API has been re-written to be more compatible with the `openmmtools` API. This means one can turn a regular `Markov Chain Monte Carlo (MCMC) <https://openmmtools.readthedocs.io/en/0.18.1/mcmc.html#mcmc-move-types>`_ move from the `openmmtools` library into an NCMC move to be used in this package. In this case, one simply needs to make use of dual inheritance, using the `blues.ncmc.NCMCMove` that we provide and override the `_get_integrator()` function to make use of the `blues.integrator.AlchemicalExternalLangevinIntegrator`. When using dual inheritance, it is important that you first inherit the desired MCMC move and then the provided `blues.ncmc.NCMCMove` class. For example, if we wanted to take the `openmmtools.mcmc.MCDisplacementMove` class and turn it into an NCMC move, it would look like:

.. code-block:: python
   from blues.ncmc import NCMCMove
   from openmmtools.mcmc import MCDisplacementMove
   class NCMCDisplacementMove(MCDisplacementMove, NCMCMove):
       def _get_integrator(self, thermodynamic_state):
           return NCMCMove._get_integrator(self,thermodynamic_state)

OpenMMTools Objects
------------------
Highlighted in red are 3 objects that we use from the `openmmtools` library. They are the `ThermodynamicState`, `CompoundThermodynamicState`, and `SamplerState` objects. For more details of each class, please see the official `openmmtools documentation <https://openmmtools.readthedocs.io/en/0.18.1/states.html#thermodynamic-and-sampler-states>`_.

Briefly, the `ThermodynamicState` class represents the portion of the state of an `openmm.Context` that does not change with integration (i.e. particles, temperature, or pressure). The `CompoundThermodynamicState` class is essentially the same as the `ThermodynamicState` class except in this package, it is used for the handling the `openmmtools.alchemy.AlchemicalState` object. Thus, in order to create the `CompoundThermodynamicState`, one needs to first create the plain `ThermodynamicState` object first. If a `CompoundThermodynamicState` object is not provided to the `blues.ncmc.BLUESSampler` class, one is created using the default parameters from the given `ThermodynamicState`. Lastly, the `SamplerState` class represents the state of an `openmm.Context` which does change with integration (i.e positions, velocities, and box_vectors). Within the context of this package, the `SamplerState` is used to sync information between the MD and NCMC simulations.


BLUESSampler
------------
.. _usage:
The `blues.ncmc.BLUESSampler` object ties together all the previously mentioned state objects and the two move classes for running the NCMC+MD simulation. For a more detailed example of it's usage see the :ref:`usage` documentation.
