Developer Guide
=======================

UML Diagram
-----------
.. image:: ../images/uml.png

OpenMMTools Objects
-------------------
Highlighted in red are 3 objects that we use from the `openmmtools` library. They are the `ThermodynamicState`, `CompoundThermodynamicState`, and `SamplerState` objects. For more details of each class, please see the official `openmmtools documentation <https://openmmtools.readthedocs.io/en/0.18.1/states.html#thermodynamic-and-sampler-states>`_.

Briefly, the `ThermodynamicState` class represents the portion of the state of an `openmm.Context` that does not change with integration (i.e. particles, temperature, or pressure). The `CompoundThermodynamicState` class is essentially the same as the `ThermodynamicState` class except in this package, it is used for the handling the `openmmtools.alchemy.AlchemicalState` object. Thus, in order to create the `CompoundThermodynamicState`, one needs to first create the plain `ThermodynamicState` object first. If a `CompoundThermodynamicState` object is not provided to the `blues.ncmc.BLUESSampler` class, one is created using the default parameters from the given `ThermodynamicState`. Lastly, the `SamplerState` class represents the state of an `openmm.Context` which does change with integration (i.e positions, velocities, and box_vectors). Within the context of this package, the `SamplerState` is used to sync information between the MD and NCMC simulations.

Integrators and Moves
---------------------
Integrators are the lowest level openmm objects this package interacts with, where each intergrator is tied to an `openmm.Context` that it advances. Each integrator is generated by using the embedded function  `_get_integrator()` function within each move class. The integrators will control whether we are carrying out the Non-equilibirum Candidate Monte Carlo (NCMC) or Molecular Dynamics (MD) simulation.

Every move class has 3 hidden functions: `_get_integrator()` for generating the integrator of each move class, `_before_integration()` for performing any necessary setup before integration, and `_after_integration()` for performing any cleanup or data collection after integration. Every move class also contains the `apply()` function which carries out stepping with the integrator.

In this package, we provide the move class `blues.ncmc.ReportLangevinDynamicsMove` to execute the MD simulation. As the name suggests, this will carry forward the MD simulation using Langevin dynamics, by generating an `openmm.LangevinIntegrator`. This class is essentially the same as the `openmmtools.LangevinDynamicsMove` but with modifications to the `apply()` function which allows storing simulation data for the MD simulation.

For running the NCMC simulation, we provide a custom integrator
`blues.integrator.AlchemicalExternalLangevinIntegrator`. This integrator is generated in every move which inherits from the base class `blues.ncmc.NCMCMove`. Every class which inherits from the base move class must override the `_propose_positions()` function. If necessary, one can override the `_before_integration()` and `_after_integration()` functions for any necessary setup and cleanup before a call is made to the `apply()` function to step forward with integrating the `openmm.Context`.

In order to implement custom NCMC moves, inherit from the base class and override the `_propose_positions()` function. This function takes in the positions array of the atoms to be modified and returns the proposed positions. In pseudo-code, it would look something like:

.. code-block:: python

   from blues.ncmc import NCMCMove
   class CustomNCMCMove(NCMCMove):
       def _propose_positions(positions):
           """Add 1 nanometer displacement vector."""
           positions_unit = positions.unit
           unitless_displacement = 1.0 / positions_unit
           displacement_vector = unit.Quantity(np.random.randn(3) * unitless_displacement_sigma, positions_unit)
           proposed_positions = positions + displacement_vector
           return proposed_positions

In this package, we provide the `blues.ncmc.RandomLigandRotationMove` in order to propose a random ligand rotation about the center of mass. This class overrides the `_before_integration()` function for obtaining the masses of the ligand and overrides the `_propose_positions()` function for generating the rotated coordinates. Applying the rotated coordinates to the context is handled when the `apply()` function is called in this move class. Code snippet of the class is shown below:

.. code-block:: python

   from blues.ncmc import RandomLigandRotationMove
   class RandomLigandRotationMove(NCMCMove):
      def _before_integration(self, context, thermodynamic_state):
         """Obtain the masses of the ligand before integration."""
         super(RandomLigandRotationMove, self)._before_integration(context, thermodynamic_state)
         masses, totalmass = utils.getMasses(self.atom_subset, thermodynamic_state.topology)
         self.masses = masses
      def _propose_positions(self, positions):
          # Calculate the center of mass
          center_of_mass = utils.getCenterOfMass(positions, self.masses)
          reduced_pos = positions - center_of_mass
          # Define random rotational move on the ligand
          rand_quat = mdtraj.utils.uniform_quaternion(size=None)
          rand_rotation_matrix = mdtraj.utils.rotation_matrix_from_quaternion(rand_quat)
          # multiply lig coordinates by rot matrix and add back COM translation from origin
          proposed_positions = numpy.dot(reduced_pos, rand_rotation_matrix) * positions.unit + center_of_mass

          return proposed_positions

Since BLUES (v0.2.5) the API has been re-written to be more compatible with the `openmmtools` API. This means one can turn a regular `Markov Chain Monte Carlo (MCMC) <https://openmmtools.readthedocs.io/en/0.18.1/mcmc.html#mcmc-move-types>`_ move from the `openmmtools` library into an NCMC move to be used in this package. In this case, one simply needs to make use of dual inheritance, using the `blues.ncmc.NCMCMove` that we provide and override the `_get_integrator()` function to make use of the `blues.integrator.AlchemicalExternalLangevinIntegrator`. When using dual inheritance, it is important that you first inherit the desired MCMC move and then the provided `blues.ncmc.NCMCMove` class. For example, if we wanted to take the `openmmtools.mcmc.MCDisplacementMove` class and turn it into an NCMC move, it would look like:

.. code-block:: python

   from blues.ncmc import NCMCMove
   from openmmtools.mcmc import MCDisplacementMove
   class NCMCDisplacementMove(MCDisplacementMove, NCMCMove):
       def _get_integrator(self, thermodynamic_state):
           return NCMCMove._get_integrator(self,thermodynamic_state)




BLUESSampler
------------
The `blues.ncmc.BLUESSampler` object ties together all the previously mentioned state objects and the two move classes for running the NCMC+MD simulation. For a more detailed example of it's usage see the :doc:`usage` documentation. When the `run()` function is called the following takes place:

- Initialization:
   - `_printSimulationTiming()` : Calculation of total number of steps
   - `equil()` : Equilibration
- BLUES iterations:
   - `ncmc_move.apply()` : NCMC simulation
   - `_acceptRejectMove()` : Metropolization
   - `dynamics_move.apply()` : MD Simulation

Initialization
``````````````
The first thing that occurs when `run()` is called is the initialization stage. During this stage, a call is made to `_printSimulationTiming()` which will print out the total number of force evaluations and simulation time. The output will look something like below:

.. code-block:: python

   Total BLUES Simulation Time = 4.0 ps (0.04 ps/Iter)
   Total Force Evaluations = 4000
   Total NCMC time = 2.0 ps (0.02 ps/iter)
   Total MD time = 2.0 ps (0.02 ps/iter)

In the `blues.ncmc.BLUESSampler` class, there is an `equil()` function which lets you run iterations of just the MD simulation in order to equilibrate your system before running the NCMC+MD hybrid simulation. An equilibration iteration, in this case is controlled by the given parameter `n_steps` for the input `dynamics_move` class. For example, if I create a `blues.ncmc.ReportLangevinDynamicsMove` class with `n_steps=20` and run the `blues.ncmc.BLUESSampler()` class with `n_iterations=100`, this will run `(n_steps * n_iterations)` or 2000 steps of MD or 2 picoseconds of MD simulation time. If the `run()` function is called without prior equilibration, it will always run 1 iteration of equilibration to set the initial conditions in the MD simulation, prior to running the NCMC simulation.

BLUES Iterations
````````````````
**NCMC Simulation**
After at least 1 iteration of equilibration, the `blues.ncmc.BLUESSampler` class will then proceed forward with running iterations of the NCMC+MD hybrid simulation. It will first run the NCMC simulation by calling the `apply()` method on the `ncmc_move` class or for sake of example, the `blues.ncmc.RandomLigandRotationMove` class. The `apply()` method for the `ncmc_move` will take in the `alch_thermodynamic_state` parameter or specifically the `CompoundThermodynamicState` object.

When the `apply()` method on `ncmc_move` is called, it will first generate the `blues.integrators.AlchemicalExternalLangevinIntegrator` by calling `_get_integrator()` method embedded within the move class. Then, it will create (or fetch from the `context_cache`) a corresponding `openmm.Context` given the `alch_thermodynamic_state`. Next, the `SamplerState` which contains the last state of the MD simulation is synced to the newly created context corresponding to the `alch_thermodynamic_state`. Particularly, the context will be updated with the box_vectors, positions, and velocities from the MD simulation. Just prior to integration, a call is made to the `_before_integration()` method in order to store the initial energies, positions and the masses of the ligand to be rotated. Then, we actually step with the integrator where we perform the ligand rotation when lambda has reached the half-way point or `lambda=0.5` and continue integration until we have completed `n_steps`. After the integration steps have been completed, a call is made to the `_after_integration()` method to store the final energies and positions. Lastly, the `SamplerState` object is updated from the final state of the context.


**Metropolization**
After advancing the NCMC simulation, a call is made to the `_acceptRejectMove()` method in the `BLUESSampler` class for the metropolization of the proposed move. Here, is we compute a correction term for switching between the MD and NCMC integrators and factor this in with acceptance probability (LogPAcceptance). Then, a random number is generated in which: the move is accepted if the random number is less than the LogPAcceptance and rejected if greater. When the move is rejected, we set the positions on the `SamplerState` to the initial positions from the NCMC simulation. If the move is accepted, nothing on the `SamplerState` is updated.

**MD Simulation** 
